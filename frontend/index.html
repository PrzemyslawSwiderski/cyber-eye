<!DOCTYPE html>
<html>

<head>
  <title>H264 Viewer</title>
  <style>
    body {
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
      gap: 12px;
    }

    canvas {
      max-width: 100%;
      transform: rotate(180deg);
    }

    #overlay {
      position: absolute;
      top: 8px;
      left: 8px;
      color: #0f0;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.6);
      padding: 4px 8px;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #aaa;
      font: 14px monospace;
      cursor: pointer;
      user-select: none;
    }

    .toggle-label input[type="checkbox"] {
      appearance: none;
      width: 36px;
      height: 20px;
      background: #555;
      border-radius: 10px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .toggle-label input[type="checkbox"]:checked {
      background: #2a2;
    }

    .toggle-label input[type="checkbox"]::after {
      content: '';
      position: absolute;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: left 0.2s;
    }

    .toggle-label input[type="checkbox"]:checked::after {
      left: 19px;
    }

    button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      font: bold 14px monospace;
      cursor: pointer;
    }

    #btnConnect {
      background: #2a2;
      color: #fff;
    }

    #btnDisconnect {
      background: #a22;
      color: #fff;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    #wrapper {
      position: relative;
      display: inline-block;
    }
  </style>
</head>

<body>
  <div id="wrapper">
    <canvas id="canvas"></canvas>
    <div id="overlay">
      <span id="statusText">Disconnected</span>
      <span id="fpsText">FPS: --</span>
      <span id="signalText">Signal: --</span>
    </div>
  </div>
  <div id="controls">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <label class="toggle-label">
      <input type="checkbox" id="toggleSignal" checked>
      Signal
    </label>
  </div>

  <script id="workerCode">

    function concat(...arrays) {
      const out = new Uint8Array(arrays.reduce((n, a) => n + a.byteLength, 0));
      let offset = 0;
      for (const a of arrays) { out.set(a, offset); offset += a.byteLength; }
      return out;
    }

    function splitNalUnits(data) {
      const nals = [];
      let start = -1;
      for (let i = 0; i < data.length - 3; i++) {
        const is4 = data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0 && data[i + 3] === 1;
        const is3 = data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 1;
        if (is4 || is3) {
          if (start !== -1) nals.push(data.slice(start, i));
          start = i + (is4 ? 4 : 3);
          i += is4 ? 3 : 2;
        }
      }
      if (start !== -1) nals.push(data.slice(start));
      return nals;
    }

    function toAvcc(nal) {
      const buf = new ArrayBuffer(4 + nal.byteLength);
      new DataView(buf).setUint32(0, nal.byteLength, false);
      new Uint8Array(buf, 4).set(nal);
      return new Uint8Array(buf);
    }

    function buildExtradata(sps, pps) {
      return new Uint8Array([
        1, sps[1], sps[2], sps[3], 0xFF, 0xE1,
        (sps.length >> 8) & 0xFF, sps.length & 0xFF, ...sps,
        0x01,
        (pps.length >> 8) & 0xFF, pps.length & 0xFF, ...pps,
      ]);
    }

    let decoder = null, sps = null, pps = null;
    let frameCount = 0, lastFpsTime = performance.now();

    function createDecoder() {
      return new VideoDecoder({
        output(frame) {
          frameCount++;
          const now = performance.now(), delta = now - lastFpsTime;
          if (delta >= 500) {
            self.postMessage({ type: 'fps', fps: Math.round(frameCount / delta * 1000) });
            frameCount = 0; lastFpsTime = now;
          }
          createImageBitmap(frame).then(bitmap => {
            frame.close();
            self.postMessage({ type: 'frame', bitmap }, [bitmap]);
          });
        },
        error(e) { self.postMessage({ type: 'error', message: e.message }); }
      });
    }

    function feedNals(nals) {
      const frameNals = [];
      let isKey = false;

      for (const nal of nals) {
        const type = nal[0] & 0x1F;
        if (type === 7) { sps = nal; continue; }
        if (type === 8) { pps = nal; continue; }

        if (sps && pps && decoder.state === 'unconfigured') {
          decoder.configure({
            codec: 'avc1.42c029',
            description: buildExtradata(sps, pps),
            optimizeForLatency: true,
          });
        }

        if (type === 5) isKey = true;
        frameNals.push(toAvcc(nal));
      }

      if (!frameNals.length || decoder.state !== 'configured') return;

      decoder.decode(new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: performance.now() * 1000,
        data: concat(...frameNals),
      }));
    }

    let abortController = null;

    async function startStream(url) {
      sps = null; pps = null;
      frameCount = 0; lastFpsTime = performance.now();
      abortController = new AbortController();
      decoder = createDecoder();

      try {
        const response = await fetch(url, { signal: abortController.signal });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        self.postMessage({ type: 'status', text: 'Streaming' });

        const reader = response.body.getReader();
        let remainder = new Uint8Array(0);

        while (true) {
          const { value, done } = await reader.read();
          if (done) { self.postMessage({ type: 'status', text: 'Stream ended' }); break; }

          const chunk = concat(remainder, value);
          const nals = splitNalUnits(chunk);
          if (nals.length > 1) {
            feedNals(nals.slice(0, -1));
            const last = nals[nals.length - 1];
            remainder = chunk.slice(chunk.length - last.length - 4);
          } else {
            remainder = chunk;
          }
        }
      } catch (e) {
        self.postMessage({ type: 'status', text: e.name === 'AbortError' ? 'Disconnected' : `Error: ${e.message}` });
      } finally {
        if (decoder && decoder.state !== 'closed') decoder.close();
        decoder = null;
        self.postMessage({ type: 'done' });
      }
    }

    self.onmessage = (e) => {
      if (e.data.type === 'start') startStream(e.data.url);
      if (e.data.type === 'stop' && abortController) abortController.abort();
    };

  </script>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('bitmaprenderer');
    const statusText = document.getElementById('statusText');
    const fpsText = document.getElementById('fpsText');
    const signalText = document.getElementById('signalText');
    const btnConnect = document.getElementById('btnConnect');
    const btnDisconnect = document.getElementById('btnDisconnect');
    const toggleSignal = document.getElementById('toggleSignal');

    function createWorker() {
      const blob = new Blob([document.getElementById('workerCode').textContent], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }

    let worker = null, pendingBitmap = null, rafScheduled = false;

    function renderFrame() {
      rafScheduled = false;
      if (!pendingBitmap) return;
      ctx.transferFromImageBitmap(pendingBitmap);
      pendingBitmap = null;
    }

    function onWorkerMessage(e) {
      const msg = e.data;
      switch (msg.type) {
        case 'frame':
          if (msg.bitmap.width !== canvas.width || msg.bitmap.height !== canvas.height) {
            canvas.width = msg.bitmap.width; canvas.height = msg.bitmap.height;
          }
          if (pendingBitmap) pendingBitmap.close();
          pendingBitmap = msg.bitmap;
          if (!rafScheduled) { rafScheduled = true; requestAnimationFrame(renderFrame); }
          break;
        case 'fps': fpsText.textContent = `FPS: ${msg.fps}`; break;
        case 'status': statusText.textContent = msg.text; break;
        case 'error': statusText.textContent = `Error: ${msg.message}`; break;
        case 'done': cleanup(); break;
      }
    }

    // ---- Signal polling ----

    let signalInterval = null, signalPending = false;

    function pollSignal() {
      if (!toggleSignal.checked || signalPending) return;

      const run = async (deadline) => {
        if (pendingBitmap || (deadline && deadline.timeRemaining() < 10)) { scheduleSignalPoll(500); return; }
        signalPending = true;
        try {
          const res = await fetch('http://192.168.1.17:8080/api/signal/info', { signal: AbortSignal.timeout(200) });
          const { wifi_signal_strength: s } = await res.json();
          signalText.textContent = `Signal: ${s} dBm ${signalBars(s)}`;
        } catch (e) {
          signalText.textContent = e.name === 'TimeoutError' ? 'Signal: timeout' : 'Signal: N/A';
        } finally {
          signalPending = false;
        }
      };

      if (typeof scheduler !== 'undefined' && scheduler.postTask)
        scheduler.postTask(() => run(null), { priority: 'background' });
      else if (typeof requestIdleCallback !== 'undefined')
        requestIdleCallback(run, { timeout: 2000 });
      else
        setTimeout(() => run(null), 0);
    }

    function scheduleSignalPoll(delay = 3000) {
      clearTimeout(signalInterval); clearInterval(signalInterval);
      signalInterval = setTimeout(() => { pollSignal(); signalInterval = setInterval(pollSignal, 3000); }, delay);
    }

    function signalBars(dbm) {
      if (dbm >= -50) return '▂▄▆█';
      if (dbm >= -60) return '▂▄▆_';
      if (dbm >= -70) return '▂▄__';
      if (dbm >= -80) return '▂___';
      return '____';
    }

    // ---- Connect / disconnect ----

    function connect() {
      btnConnect.disabled = true; btnDisconnect.disabled = false;
      statusText.textContent = 'Connecting...'; fpsText.textContent = 'FPS: --';
      if (pendingBitmap) { pendingBitmap.close(); pendingBitmap = null; }
      worker = createWorker();
      worker.onmessage = onWorkerMessage;
      worker.postMessage({ type: 'start', url: 'http://192.168.1.17:8080/stream.h264' });
      scheduleSignalPoll(1000);
    }

    function disconnect() { if (worker) worker.postMessage({ type: 'stop' }); }

    function cleanup() {
      clearTimeout(signalInterval); clearInterval(signalInterval); signalInterval = null;
      if (pendingBitmap) { pendingBitmap.close(); pendingBitmap = null; }
      if (worker) { worker.terminate(); worker = null; }
      fpsText.textContent = 'FPS: --'; signalText.textContent = 'Signal: --';
      btnConnect.disabled = false; btnDisconnect.disabled = true;
    }

    toggleSignal.addEventListener('change', () => {
      if (!toggleSignal.checked) {
        clearTimeout(signalInterval); clearInterval(signalInterval);
        signalInterval = null; signalText.textContent = 'Signal: off';
      } else if (worker) { scheduleSignalPoll(500); }
    });

    btnConnect.addEventListener('click', connect);
    btnDisconnect.addEventListener('click', disconnect);
  </script>
</body>

</html>
