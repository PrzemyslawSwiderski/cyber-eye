<!DOCTYPE html>
<html>

<head>
  <title>H264 Viewer</title>
  <style>
    body {
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
      gap: 12px;
    }

    canvas {
      max-width: 100%;
      transform: rotate(180deg);
    }

    #overlay {
      position: absolute;
      top: 8px;
      left: 8px;
      color: #0f0;
      font: 14px monospace;
      background: rgba(0, 0, 0, 0.6);
      padding: 4px 8px;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #aaa;
      font: 14px monospace;
      cursor: pointer;
      user-select: none;
    }

    .toggle-label input[type="checkbox"] {
      appearance: none;
      width: 36px;
      height: 20px;
      background: #555;
      border-radius: 10px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .toggle-label input[type="checkbox"]:checked {
      background: #2a2;
    }

    .toggle-label input[type="checkbox"]::after {
      content: '';
      position: absolute;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: left 0.2s;
    }

    .toggle-label input[type="checkbox"]:checked::after {
      left: 19px;
    }

    button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      font: bold 14px monospace;
      cursor: pointer;
    }

    #btnConnect {
      background: #2a2;
      color: #fff;
    }

    #btnDisconnect {
      background: #a22;
      color: #fff;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    #wrapper {
      position: relative;
      display: inline-block;
    }
  </style>
</head>

<body>
  <div id="wrapper">
    <canvas id="canvas"></canvas>
    <div id="overlay">
      <span id="statusText">Disconnected</span>
      <span id="fpsText">FPS: --</span>
      <span id="signalText">Signal: --</span>
    </div>
  </div>
  <div id="controls">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <label class="toggle-label">
      <input type="checkbox" id="toggleSignal" checked>
      Signal
    </label>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('bitmaprenderer');
    const statusText = document.getElementById('statusText');
    const fpsText = document.getElementById('fpsText');
    const signalText = document.getElementById('signalText');
    const btnConnect = document.getElementById('btnConnect');
    const btnDisconnect = document.getElementById('btnDisconnect');
    const toggleSignal = document.getElementById('toggleSignal');

    // --- FPS ---
    let fps = 0, frameCount = 0, lastTime = performance.now();
    function updateFps() {
      frameCount++;
      const now = performance.now();
      const delta = now - lastTime;
      if (delta >= 500) {
        fps = Math.round((frameCount / delta) * 1000);
        frameCount = 0;
        lastTime = now;
        fpsText.textContent = `FPS: ${fps}`;
      }
    }

    // --- Signal polling ---
    let signalInterval = null;
    let signalPending = false;

    function pollSignal() {
      if (!toggleSignal.checked) return;
      if (signalPending) return;

      // Use idle callback to yield priority to stream + rendering
      const run = async (deadline) => {
        // If we have a pending frame or very little idle time, reschedule
        if (pendingFrame || (deadline && deadline.timeRemaining() < 10)) {
          scheduleSignalPoll(500);
          return;
        }

        signalPending = true;
        try {
          const res = await fetch('http://192.168.1.17:8080/api/signal/info', {
            signal: AbortSignal.timeout(200)
          });
          const json = await res.json();
          const strength = json.wifi_signal_strength;
          signalText.textContent = `Signal: ${strength} dBm ${signalBars(strength)}`;
        } catch (e) {
          signalText.textContent = e.name === 'TimeoutError' ? 'Signal: timeout' : 'Signal: N/A';
        } finally {
          signalPending = false;
        }
      };

      if (typeof scheduler !== 'undefined' && scheduler.postTask) {
        // Chromium: explicitly background priority
        scheduler.postTask(() => run(null), { priority: 'background' });
      } else if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(run, { timeout: 2000 });
      } else {
        // Fallback: at least defer past current frame
        setTimeout(() => run(null), 0);
      }
    }

    function scheduleSignalPoll(delay = 3000) {
      clearInterval(signalInterval);
      signalInterval = setTimeout(() => {
        pollSignal();
        // Restart regular interval after first deferred poll
        signalInterval = setInterval(pollSignal, 3000);
      }, delay);
    }

    function signalBars(dbm) {
      if (dbm >= -50) return '▂▄▆█';
      if (dbm >= -60) return '▂▄▆_';
      if (dbm >= -70) return '▂▄__';
      if (dbm >= -80) return '▂___';
      return '____';
    }

    // --- NAL parsing ---
    function splitNalUnits(data) {
      const nals = [];
      let start = -1;
      for (let i = 0; i < data.length - 3; i++) {
        const is4 = data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0 && data[i + 3] === 1;
        const is3 = data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 1;
        if (is4 || is3) {
          if (start !== -1) nals.push(data.slice(start, i));
          start = i + (is4 ? 4 : 3);
          i += is4 ? 3 : 2;
        }
      }
      if (start !== -1) nals.push(data.slice(start));
      return nals;
    }

    function getNalType(nal) { return nal[0] & 0x1F; }

    function buildExtradata(sps, pps) {
      return new Uint8Array([
        1, sps[1], sps[2], sps[3], 0xFF, 0xE1,
        (sps.length >> 8) & 0xFF, sps.length & 0xFF, ...sps,
        0x01,
        (pps.length >> 8) & 0xFF, pps.length & 0xFF, ...pps,
      ]);
    }

    function toAvcc(nal) {
      const buf = new ArrayBuffer(4 + nal.byteLength);
      new DataView(buf).setUint32(0, nal.byteLength, false);
      new Uint8Array(buf, 4).set(nal);
      return new Uint8Array(buf);
    }

    function concat(...arrays) {
      const out = new Uint8Array(arrays.reduce((n, a) => n + a.byteLength, 0));
      let offset = 0;
      for (const a of arrays) { out.set(a, offset); offset += a.byteLength; }
      return out;
    }

    // --- Decoder ---
    let decoder = null;
    let sps = null, pps = null;
    let pendingFrame = null;
    let rafScheduled = false;

    function renderFrame() {
      rafScheduled = false;
      if (!pendingFrame) return;

      createImageBitmap(pendingFrame).then(bitmap => {
        pendingFrame.close();
        pendingFrame = null;
        ctx.transferFromImageBitmap(bitmap);
        updateFps();
      });
    }

    function createDecoder() {
      return new VideoDecoder({
        output(frame) {
          // Resize canvas once on first frame
          if (canvas.width !== frame.displayWidth || canvas.height !== frame.displayHeight) {
            canvas.width = frame.displayWidth;
            canvas.height = frame.displayHeight;
          }
          // Drop previous pending frame if display hasn't caught up
          if (pendingFrame) pendingFrame.close();
          pendingFrame = frame;

          if (!rafScheduled) {
            rafScheduled = true;
            requestAnimationFrame(renderFrame);
          }
        },
        error(e) {
          console.error('Decoder error:', e);
          statusText.textContent = 'Decoder error';
        }
      });
    }

    function feedNals(nals) {
      const frameNals = [];
      let isKey = false;

      for (const nal of nals) {
        const type = getNalType(nal);
        if (type === 7) { sps = nal; continue; }
        if (type === 8) { pps = nal; continue; }

        if (sps && pps && decoder.state === 'unconfigured') {
          decoder.configure({
            codec: `avc1.${sps[1].toString(16).padStart(2, '0')}${sps[2].toString(16).padStart(2, '0')}${sps[3].toString(16).padStart(2, '0')}`,
            description: buildExtradata(sps, pps),
            optimizeForLatency: true,
          });
        }

        if (type === 5) isKey = true;
        frameNals.push(toAvcc(nal));
      }

      if (!frameNals.length || decoder.state !== 'configured') return;

      decoder.decode(new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: performance.now() * 1000,
        data: concat(...frameNals),
      }));
    }

    // --- Stream control ---
    let abortController = null;

    async function connect() {
      btnConnect.disabled = true;
      btnDisconnect.disabled = false;
      statusText.textContent = 'Connecting...';

      // Reset state
      sps = null; pps = null;
      if (pendingFrame) { pendingFrame.close(); pendingFrame = null; }
      decoder = createDecoder();
      abortController = new AbortController();

      // Start signal polling
      scheduleSignalPoll(1000);

      try {
        const response = await fetch('http://192.168.1.17:8080/stream.h264', {
          signal: abortController.signal
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        statusText.textContent = 'Streaming';
        const reader = response.body.getReader();
        let remainder = new Uint8Array(0);

        while (true) {
          const { value, done } = await reader.read();
          if (done) { statusText.textContent = 'Stream ended'; break; }

          const chunk = concat(remainder, value);
          const nals = splitNalUnits(chunk);
          if (nals.length > 1) {
            feedNals(nals.slice(0, -1));
            const last = nals[nals.length - 1];
            remainder = chunk.slice(chunk.length - last.length - 4);
          } else {
            remainder = chunk;
          }
        }
      } catch (e) {
        if (e.name === 'AbortError') {
          statusText.textContent = 'Disconnected';
        } else {
          statusText.textContent = `Error: ${e.message}`;
          console.error(e);
        }
      } finally {
        cleanup();
      }
    }

    function disconnect() {
      if (abortController) abortController.abort();
    }

    function cleanup() {
      clearInterval(signalInterval);
      clearTimeout(signalInterval);
      signalInterval = null;
      if (pendingFrame) { pendingFrame.close(); pendingFrame = null; }
      if (decoder && decoder.state !== 'closed') decoder.close();
      decoder = null;
      fpsText.textContent = 'FPS: --';
      signalText.textContent = 'Signal: --';
      btnConnect.disabled = false;
      btnDisconnect.disabled = true;
    }

    toggleSignal.addEventListener('change', () => {
      if (!toggleSignal.checked) {
        clearInterval(signalInterval);
        clearTimeout(signalInterval);
        signalInterval = null;
        signalText.textContent = 'Signal: off';
      } else if (decoder) {
        scheduleSignalPoll(500); // re-enable with short delay
      }
    });

    btnConnect.addEventListener('click', connect);
    btnDisconnect.addEventListener('click', disconnect);
  </script>
</body>

</html>
